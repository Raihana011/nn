<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>StarryNet AR ‚Äî Van Gogh-ish Neural Network</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#05060b; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; }
    #hud {
      position:fixed; left:12px; top:12px; z-index:10;
      padding:10px 12px; border-radius:14px;
      background: rgba(10, 12, 22, 0.55);
      color:#e9ecff; backdrop-filter: blur(10px);
      box-shadow: 0 8px 24px rgba(0,0,0,.35);
      max-width: 360px;
    }
    #hud b { display:block; margin-bottom:6px; }
    #hud small { opacity:.9; line-height:1.35; display:block; }
    #btnRow { display:flex; gap:8px; margin-top:10px; flex-wrap:wrap; }
    button {
      border:0; padding:10px 12px; border-radius:12px; cursor:pointer;
      background: rgba(255,255,255,0.08); color:#fff;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    button:hover { background: rgba(255,255,255,0.12); }
    #status { margin-top:8px; font-size: 12px; opacity:.9; }
    #err {
      position:fixed; inset:0; display:none; z-index:9999;
      background: rgba(0,0,0,.85); color:#fff; padding:18px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap; overflow:auto;
    }
    canvas { display:block; width:100%; height:100%; }
  </style>
</head>
<body>
  <div id="hud">
    <b>StarryNet AR</b>
    <small>Desktop: drag to orbit, scroll to zoom. Click nodes to ‚Äúfire‚Äù.</small>
    <small id="hint">Phone (supported): press <b>Enter AR</b>, move to find a surface, tap to place.</small>
    <div id="btnRow">
      <button id="enterArBtn">Enter AR</button>
      <button id="regenBtn">Regenerate</button>
      <button id="pulseBtn">Pulse</button>
    </div>
    <div id="status">Status: loading modules‚Ä¶</div>
  </div>
  <div id="err"></div>

  <script type="module">
    const statusEl = document.getElementById("status");
    const errEl = document.getElementById("err");
    const enterArBtn = document.getElementById("enterArBtn");
    const regenBtn = document.getElementById("regenBtn");
    const pulseBtn = document.getElementById("pulseBtn");

    function showError(e) {
      console.error(e);
      errEl.style.display = "block";
      errEl.textContent =
        "üí• Runtime error:\n\n" +
        (e?.stack || e?.message || String(e)) +
        "\n\nCommon fixes:\n" +
        "1) Serve via http:// (not file://)\n" +
        "2) Check DevTools Console for module 404/CORS\n" +
        "3) Try another browser/device\n";
      statusEl.textContent = "Status: error (see overlay).";
    }

    window.addEventListener("error", (ev) => showError(ev.error || ev.message));
    window.addEventListener("unhandledrejection", (ev) => showError(ev.reason));

    try {
      // More reliable CDN
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";
      const [{ OrbitControls }, { ARButton }] = await Promise.all([
        import("https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"),
        import("https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/webxr/ARButton.js"),
      ]);

      statusEl.textContent = "Status: initializing scene‚Ä¶";

      // ---------- Basic scene ----------
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x05060b, 0.18);

      const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.01, 50);
      camera.position.set(0.9, 0.8, 1.8);

      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
      renderer.setPixelRatio(devicePixelRatio);
      renderer.setSize(innerWidth, innerHeight);
      renderer.setClearColor(0x05060b, 1);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0x6c7bff, 0x06040a, 0.7);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xfff1c7, 0.85);
      dir.position.set(2, 4, 1);
      scene.add(dir);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.target.set(0, 0.2, 0);

      // ---------- ‚ÄúStarry Night‚Äù shader (procedural vibe) ----------
      const starryMaterial = new THREE.ShaderMaterial({
        transparent: true,
        uniforms: {
          uTime: { value: 0 },
          uTintA: { value: new THREE.Color("#0b1a6d") },
          uTintB: { value: new THREE.Color("#0a0a14") },
          uGold:  { value: new THREE.Color("#ffd37a") },
          uCyan:  { value: new THREE.Color("#66d9ff") },
          uOpacity: { value: 0.95 },
          uEmissive: { value: 0.65 },
        },
        vertexShader: `
          varying vec3 vNormal;
          varying vec2 vUv;
          void main() {
            vUv = uv;
            vNormal = normalMatrix * normal;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
          }
        `,
        fragmentShader: `
          precision highp float;
          varying vec3 vNormal;
          varying vec2 vUv;

          uniform float uTime;
          uniform vec3 uTintA;
          uniform vec3 uTintB;
          uniform vec3 uGold;
          uniform vec3 uCyan;
          uniform float uOpacity;
          uniform float uEmissive;

          float hash(vec2 p){
            p = fract(p*vec2(123.34, 345.45));
            p += dot(p, p+34.345);
            return fract(p.x*p.y);
          }
          float noise(vec2 p){
            vec2 i=floor(p), f=fract(p);
            float a=hash(i);
            float b=hash(i+vec2(1,0));
            float c=hash(i+vec2(0,1));
            float d=hash(i+vec2(1,1));
            vec2 u=f*f*(3.0-2.0*f);
            return mix(a,b,u.x)+(c-a)*u.y*(1.0-u.x)+(d-b)*u.x*u.y;
          }
          vec2 swirl(vec2 p, float t){
            float n = noise(p*2.2 + t*0.05);
            float ang = (n*6.2831) + 0.8*sin(t*0.15);
            mat2 r = mat2(cos(ang), -sin(ang), sin(ang), cos(ang));
            return r*p;
          }
          float star(vec2 p, float size){
            float d = length(p);
            float core = smoothstep(size, size*0.35, d);
            float a = atan(p.y, p.x);
            float rays = pow(abs(sin(a*5.0))*abs(cos(a*3.0)), 6.0);
            rays *= smoothstep(size*1.6, size*0.5, d);
            return clamp(core + rays, 0.0, 1.0);
          }

          void main(){
            vec2 p = vUv*2.0 - 1.0;
            float t = uTime;

            float ridge = 0.0;
            vec2 q = p;
            for(int i=0;i<4;i++){
              q = swirl(q + vec2(0.03*float(i), -0.02*float(i)), t + float(i)*7.0);
              ridge += noise(q*3.0 + float(i)*10.0);
            }
            ridge = pow(ridge/4.0, 1.7);

            vec2 s = swirl(p*1.2, t);
            float band = noise(s*2.2 + vec2(t*0.03, -t*0.02));
            band = smoothstep(0.25, 0.78, band);

            float st = 0.0;
            vec2 sp = p*3.0 + vec2(0.0, 0.15*sin(t*0.12));
            for(int i=0;i<10;i++){
              vec2 cell = floor(sp*1.6 + float(i));
              vec2 r = fract(sp*1.6 + float(i)) - 0.5;
              float h = hash(cell + float(i)*13.2);
              float size = mix(0.05, 0.18, pow(h, 6.0));
              vec2 jitter = vec2(hash(cell+2.1), hash(cell+9.7)) - 0.5;
              st += star(r + jitter*0.15, size) * smoothstep(0.62, 1.0, h);
            }
            st = clamp(st, 0.0, 1.0);

            vec3 sky = mix(uTintB, uTintA, band);
            vec3 paint = sky;
            paint += uGold * st * 1.25;
            paint += uCyan * st * 0.35;
            paint *= (0.82 + 0.45*ridge);

            float ndl = clamp(dot(normalize(vNormal), normalize(vec3(0.25, 0.9, 0.35))), 0.0, 1.0);
            paint += uEmissive * (0.12 + 0.28*ndl);

            float vign = smoothstep(1.25, 0.2, length(p));
            paint *= (0.65 + 0.35*vign);

            gl_FragColor = vec4(paint, uOpacity);
          }
        `
      });

      // ---------- Network ----------
      let networkRoot = new THREE.Group();
      scene.add(networkRoot);

      const clickableNodes = [];
      const raycaster = new THREE.Raycaster();
      const pointer = new THREE.Vector2();

      function buildNetwork(layers = [6, 9, 7, 5]) {
        clickableNodes.length = 0;

        // Dispose old
        scene.remove(networkRoot);
        networkRoot.traverse(o => {
          if (o.geometry) o.geometry.dispose?.();
          if (o.material) o.material.dispose?.();
        });
        networkRoot = new THREE.Group();
        scene.add(networkRoot);

        networkRoot.scale.setScalar(0.55);
        networkRoot.position.set(0, 0.15, 0);

        // Background plane so you ALWAYS see something
        const bg = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 1.6), starryMaterial.clone());
        bg.material.uniforms.uOpacity.value = 0.55;
        bg.position.set(0, 0.15, -0.55);
        bg.rotation.y = 0.15;
        networkRoot.add(bg);

        const nodeGeo = new THREE.SphereGeometry(0.035, 24, 24);
        const edgeGeo = new THREE.CylinderGeometry(0.008, 0.008, 1, 16, 1, true);

        const layerCount = layers.length;
        const xSpan = 1.6;
        const x0 = -xSpan/2;
        const positions = [];

        for (let L = 0; L < layerCount; L++) {
          positions[L] = [];
          const n = layers[L];
          for (let i = 0; i < n; i++) {
            const x = x0 + (xSpan * (L/(layerCount-1)));
            const y = (i/(n-1 || 1) - 0.5) * 0.55 + (Math.random()*0.02 - 0.01);
            const z = (Math.random()*2 - 1) * 0.12 + (Math.sin((i+L)*0.6)*0.04);

            const mat = starryMaterial.clone();
            mat.uniforms.uOpacity.value = 0.95;
            mat.uniforms.uEmissive.value = 0.9;

            const node = new THREE.Mesh(nodeGeo, mat);
            node.position.set(x, y, z);
            node.userData = { layer: L, index: i, firedAt: -999 };
            positions[L][i] = node.position.clone();
            networkRoot.add(node);
            clickableNodes.push(node);
          }
        }

        const edges = new THREE.Group();
        networkRoot.add(edges);

        function addEdge(a, b) {
          const dir = new THREE.Vector3().subVectors(b, a);
          const len = dir.length();
          const mid = new THREE.Vector3().addVectors(a, b).multiplyScalar(0.5);

          const mat = starryMaterial.clone();
          mat.uniforms.uOpacity.value = 0.70;
          mat.uniforms.uEmissive.value = 0.55;

          const cyl = new THREE.Mesh(edgeGeo, mat);
          cyl.position.copy(mid);
          cyl.scale.set(1, len, 1);
          cyl.quaternion.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize());
          cyl.userData = { firedAt: -999 };
          edges.add(cyl);
        }

        for (let L = 0; L < layerCount - 1; L++) {
          const aN = layers[L], bN = layers[L+1];
          for (let i = 0; i < aN; i++) {
            const j1 = Math.floor((i / Math.max(1, aN-1)) * (bN-1));
            const j2 = Math.floor(Math.random() * bN);
            addEdge(positions[L][i], positions[L+1][j1]);
            addEdge(positions[L][i], positions[L+1][j2]);
          }
        }
      }

      buildNetwork();

      // Click to fire
      const clock = new THREE.Clock();
      function fireFrom(node) {
        const now = clock.getElapsedTime();
        node.userData.firedAt = now;
        clickableNodes.forEach(n => {
          if (n.userData.layer >= node.userData.layer) {
            const dL = n.userData.layer - node.userData.layer;
            n.userData.firedAt = Math.min(n.userData.firedAt, now + dL*0.08 + Math.random()*0.06);
          }
        });
      }

      function onPointer(e) {
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.set(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -(((e.clientY - rect.top) / rect.height) * 2 - 1)
        );
        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObjects(clickableNodes, false);
        if (hits.length) fireFrom(hits[0].object);
      }
      window.addEventListener("pointerdown", onPointer);

      regenBtn.onclick = () => buildNetwork([
        5 + Math.floor(Math.random()*4),
        8 + Math.floor(Math.random()*5),
        6 + Math.floor(Math.random()*4),
        4 + Math.floor(Math.random()*3),
      ]);

      pulseBtn.onclick = () => fireFrom(clickableNodes[Math.floor(Math.random()*clickableNodes.length)]);

      // ---------- WebXR AR ----------
      const arButton = ARButton.createButton(renderer, {
        requiredFeatures: ["hit-test"],
        optionalFeatures: ["dom-overlay"],
        domOverlay: { root: document.body }
      });
      arButton.style.display = "none";
      document.body.appendChild(arButton);
      enterArBtn.onclick = () => arButton.click();

      const reticle = new THREE.Mesh(
        new THREE.RingGeometry(0.06, 0.085, 32).rotateX(-Math.PI/2),
        new THREE.MeshBasicMaterial({ color: 0x66d9ff })
      );
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      let hitTestSource = null;
      let hitTestSourceRequested = false;
      let placedInAR = false;

      renderer.domElement.addEventListener("click", () => {
        if (!renderer.xr.isPresenting) return;
        if (!reticle.visible) return;
        networkRoot.position.setFromMatrixPosition(reticle.matrix);
        networkRoot.scale.setScalar(0.35);
        placedInAR = true;
        statusEl.textContent = "Status: placed. Tap nodes to fire.";
      });

      renderer.xr.addEventListener("sessionend", () => {
        reticle.visible = false;
        hitTestSourceRequested = false;
        hitTestSource = null;
        placedInAR = false;
        networkRoot.position.set(0, 0.15, 0);
        networkRoot.scale.setScalar(0.55);
        controls.enabled = true;
      });

      function animate() {
        const t = clock.getElapsedTime();

        networkRoot.traverse(obj => {
          if (obj.material?.uniforms?.uTime) obj.material.uniforms.uTime.value = t;
        });

        if (!renderer.xr.isPresenting) {
          networkRoot.rotation.y = 0.25 * Math.sin(t*0.25);
          networkRoot.rotation.x = 0.06 * Math.sin(t*0.33);
          controls.update();
          statusEl.textContent = "Status: 3D simulation (non-AR).";
        } else {
          controls.enabled = false;

          const session = renderer.xr.getSession();
          if (session) {
            if (!hitTestSourceRequested) {
              session.requestReferenceSpace("viewer").then((refSpace) => {
                session.requestHitTestSource({ space: refSpace }).then((source) => {
                  hitTestSource = source;
                });
              });
              session.addEventListener("end", () => {
                hitTestSourceRequested = false;
                hitTestSource = null;
              });
              hitTestSourceRequested = true;
            }

            const referenceSpace = renderer.xr.getReferenceSpace();
            const frame = renderer.xr.getFrame();
            if (hitTestSource && frame) {
              const hitTestResults = frame.getHitTestResults(hitTestSource);
              if (hitTestResults.length) {
                const pose = hitTestResults[0].getPose(referenceSpace);
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
                if (!placedInAR) statusEl.textContent = "Status: surface found. Tap to place.";
              } else {
                reticle.visible = false;
                if (!placedInAR) statusEl.textContent = "Status: searching for a surface‚Ä¶";
              }
            }
          }
        }

        // firing glow
        clickableNodes.forEach(n => {
          const dt = t - n.userData.firedAt;
          const pulse = dt >= 0 ? Math.exp(-dt*6.0) * (0.6 + 0.4*Math.sin(dt*35.0)) : 0.0;
          if (n.material?.uniforms?.uEmissive) {
            n.material.uniforms.uEmissive.value = 0.9 + 1.35 * Math.max(0.0, pulse);
          }
        });

        renderer.render(scene, camera);
      }

      renderer.setAnimationLoop(animate);

      addEventListener("resize", () => {
        camera.aspect = innerWidth/innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
      });

      // Capability hint
      const xr = navigator.xr;
      if (!xr) {
        document.getElementById("hint").textContent = "AR not available in this browser/device. Use 3D simulation.";
        enterArBtn.disabled = true;
      } else {
        try {
          const ok = await xr.isSessionSupported("immersive-ar");
          enterArBtn.disabled = !ok;
          if (!ok) document.getElementById("hint").textContent = "Immersive AR not supported here. Use 3D simulation.";
        } catch {
          enterArBtn.disabled = true;
          document.getElementById("hint").textContent = "AR support check failed. Use 3D simulation.";
        }
      }

      statusEl.textContent = "Status: ready (3D simulation).";
    } catch (e) {
      showError(e);
    }
  </script>
</body>
</html>
